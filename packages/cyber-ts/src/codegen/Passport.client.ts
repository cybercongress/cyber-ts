/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { AddressResponse, Expiration, Timestamp, Uint64, AllNftInfoResponseForPassportMetadata, OwnerOfResponse, Approval, NftInfoResponseForPassportMetadata, PassportMetadata, LabeledAddress, ApprovalResponse, ApprovalsResponse, ConfigResponse, Addr, Config, ContractInfoResponse, ExecuteMsg, CosmosMsgForCyberMsgWrapper, BankMsg, Uint128, CyberMsg, Decimal, CyberRoute, StakingMsg, DistributionMsg, WasmMsg, Binary, Coin, CyberMsgWrapper, Link, Load, Trigger, MintMsgForPassportMetadata, InstantiateMsg, MinterResponse, NumTokensResponse, OperatorsResponse, PortidResponse, QueryMsg, SignatureResponse, TokenInfoForPassportMetadata, TokensResponse } from "./Passport.types";
export interface PassportReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  lastPortid: () => Promise<PortidResponse>;
  portidByNickname: ({
    nickname
  }: {
    nickname: string;
  }) => Promise<PortidResponse>;
  addressByNickname: ({
    nickname
  }: {
    nickname: string;
  }) => Promise<AddressResponse>;
  passportByNickname: ({
    nickname
  }: {
    nickname: string;
  }) => Promise<TokenInfoForPassportMetadata>;
  metadataByNickname: ({
    nickname
  }: {
    nickname: string;
  }) => Promise<PassportMetadata>;
  passportSigned: ({
    address,
    nickname
  }: {
    address: string;
    nickname: string;
  }) => Promise<SignatureResponse>;
  activePassport: ({
    address
  }: {
    address: string;
  }) => Promise<TokenInfoForPassportMetadata>;
  ownerOf: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<OwnerOfResponse>;
  approval: ({
    includeExpired,
    spender,
    tokenId
  }: {
    includeExpired?: boolean;
    spender: string;
    tokenId: string;
  }) => Promise<ApprovalResponse>;
  approvals: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<ApprovalsResponse>;
  allOperators: ({
    includeExpired,
    limit,
    owner,
    startAfter
  }: {
    includeExpired?: boolean;
    limit?: number;
    owner: string;
    startAfter?: string;
  }) => Promise<OperatorsResponse>;
  numTokens: () => Promise<NumTokensResponse>;
  contractInfo: () => Promise<ContractInfoResponse>;
  nftInfo: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<NftInfoResponseForPassportMetadata>;
  allNftInfo: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<AllNftInfoResponseForPassportMetadata>;
  tokens: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  allTokens: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  minter: () => Promise<MinterResponse>;
}
export class PassportQueryClient implements PassportReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.lastPortid = this.lastPortid.bind(this);
    this.portidByNickname = this.portidByNickname.bind(this);
    this.addressByNickname = this.addressByNickname.bind(this);
    this.passportByNickname = this.passportByNickname.bind(this);
    this.metadataByNickname = this.metadataByNickname.bind(this);
    this.passportSigned = this.passportSigned.bind(this);
    this.activePassport = this.activePassport.bind(this);
    this.ownerOf = this.ownerOf.bind(this);
    this.approval = this.approval.bind(this);
    this.approvals = this.approvals.bind(this);
    this.allOperators = this.allOperators.bind(this);
    this.numTokens = this.numTokens.bind(this);
    this.contractInfo = this.contractInfo.bind(this);
    this.nftInfo = this.nftInfo.bind(this);
    this.allNftInfo = this.allNftInfo.bind(this);
    this.tokens = this.tokens.bind(this);
    this.allTokens = this.allTokens.bind(this);
    this.minter = this.minter.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  lastPortid = async (): Promise<PortidResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      last_portid: {}
    });
  };
  portidByNickname = async ({
    nickname
  }: {
    nickname: string;
  }): Promise<PortidResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      portid_by_nickname: {
        nickname
      }
    });
  };
  addressByNickname = async ({
    nickname
  }: {
    nickname: string;
  }): Promise<AddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      address_by_nickname: {
        nickname
      }
    });
  };
  passportByNickname = async ({
    nickname
  }: {
    nickname: string;
  }): Promise<TokenInfoForPassportMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      passport_by_nickname: {
        nickname
      }
    });
  };
  metadataByNickname = async ({
    nickname
  }: {
    nickname: string;
  }): Promise<PassportMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      metadata_by_nickname: {
        nickname
      }
    });
  };
  passportSigned = async ({
    address,
    nickname
  }: {
    address: string;
    nickname: string;
  }): Promise<SignatureResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      passport_signed: {
        address,
        nickname
      }
    });
  };
  activePassport = async ({
    address
  }: {
    address: string;
  }): Promise<TokenInfoForPassportMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      active_passport: {
        address
      }
    });
  };
  ownerOf = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<OwnerOfResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner_of: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  approval = async ({
    includeExpired,
    spender,
    tokenId
  }: {
    includeExpired?: boolean;
    spender: string;
    tokenId: string;
  }): Promise<ApprovalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      approval: {
        include_expired: includeExpired,
        spender,
        token_id: tokenId
      }
    });
  };
  approvals = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<ApprovalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      approvals: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  allOperators = async ({
    includeExpired,
    limit,
    owner,
    startAfter
  }: {
    includeExpired?: boolean;
    limit?: number;
    owner: string;
    startAfter?: string;
  }): Promise<OperatorsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_operators: {
        include_expired: includeExpired,
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  numTokens = async (): Promise<NumTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      num_tokens: {}
    });
  };
  contractInfo = async (): Promise<ContractInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_info: {}
    });
  };
  nftInfo = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<NftInfoResponseForPassportMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      nft_info: {
        token_id: tokenId
      }
    });
  };
  allNftInfo = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<AllNftInfoResponseForPassportMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_nft_info: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  tokens = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tokens: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  allTokens = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_tokens: {
        limit,
        start_after: startAfter
      }
    });
  };
  minter = async (): Promise<MinterResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      minter: {}
    });
  };
}
export interface PassportInterface extends PassportReadOnlyInterface {
  contractAddress: string;
  sender: string;
  execute: ({
    msgs
  }: {
    msgs: CosmosMsgForCyberMsgWrapper[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createPassport: ({
    avatar,
    nickname,
    signature
  }: {
    avatar: string;
    nickname: string;
    signature: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateName: ({
    newNickname,
    oldNickname
  }: {
    newNickname: string;
    oldNickname: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateAvatar: ({
    newAvatar,
    nickname
  }: {
    newAvatar: string;
    nickname: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateData: ({
    data,
    nickname
  }: {
    data?: string;
    nickname: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateParticle: ({
    nickname,
    particle
  }: {
    nickname: string;
    particle?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  proofAddress: ({
    address,
    nickname,
    signature
  }: {
    address: string;
    nickname: string;
    signature: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeAddress: ({
    address,
    nickname
  }: {
    address: string;
    nickname: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setOwner: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setActive: ({
    tokenId
  }: {
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setSubgraphs: ({
    avatarSubgraph,
    nameSubgraph,
    proofSubgraph
  }: {
    avatarSubgraph: string;
    nameSubgraph: string;
    proofSubgraph: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setAddressLabel: ({
    address,
    label,
    nickname
  }: {
    address: string;
    label?: string;
    nickname: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transferNft: ({
    recipient,
    tokenId
  }: {
    recipient: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendNft: ({
    contract,
    msg,
    tokenId
  }: {
    contract: string;
    msg: Binary;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  mint: ({
    extension,
    owner,
    tokenId,
    tokenUri
  }: {
    extension: PassportMetadata;
    owner: string;
    tokenId: string;
    tokenUri?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  burn: ({
    tokenId
  }: {
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  approve: ({
    expires,
    spender,
    tokenId
  }: {
    expires?: Expiration;
    spender: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  revoke: ({
    spender,
    tokenId
  }: {
    spender: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  approveAll: ({
    expires,
    operator
  }: {
    expires?: Expiration;
    operator: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  revokeAll: ({
    operator
  }: {
    operator: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class PassportClient extends PassportQueryClient implements PassportInterface {
  declare client: SigningCosmWasmClient;
  sender: string;
  declare contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.execute = this.execute.bind(this);
    this.createPassport = this.createPassport.bind(this);
    this.updateName = this.updateName.bind(this);
    this.updateAvatar = this.updateAvatar.bind(this);
    this.updateData = this.updateData.bind(this);
    this.updateParticle = this.updateParticle.bind(this);
    this.proofAddress = this.proofAddress.bind(this);
    this.removeAddress = this.removeAddress.bind(this);
    this.setOwner = this.setOwner.bind(this);
    this.setActive = this.setActive.bind(this);
    this.setSubgraphs = this.setSubgraphs.bind(this);
    this.setAddressLabel = this.setAddressLabel.bind(this);
    this.transferNft = this.transferNft.bind(this);
    this.sendNft = this.sendNft.bind(this);
    this.mint = this.mint.bind(this);
    this.burn = this.burn.bind(this);
    this.approve = this.approve.bind(this);
    this.revoke = this.revoke.bind(this);
    this.approveAll = this.approveAll.bind(this);
    this.revokeAll = this.revokeAll.bind(this);
  }

  execute = async ({
    msgs
  }: {
    msgs: CosmosMsgForCyberMsgWrapper[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      execute: {
        msgs
      }
    }, fee, memo, _funds);
  };
  createPassport = async ({
    avatar,
    nickname,
    signature
  }: {
    avatar: string;
    nickname: string;
    signature: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_passport: {
        avatar,
        nickname,
        signature
      }
    }, fee, memo, _funds);
  };
  updateName = async ({
    newNickname,
    oldNickname
  }: {
    newNickname: string;
    oldNickname: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_name: {
        new_nickname: newNickname,
        old_nickname: oldNickname
      }
    }, fee, memo, _funds);
  };
  updateAvatar = async ({
    newAvatar,
    nickname
  }: {
    newAvatar: string;
    nickname: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_avatar: {
        new_avatar: newAvatar,
        nickname
      }
    }, fee, memo, _funds);
  };
  updateData = async ({
    data,
    nickname
  }: {
    data?: string;
    nickname: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_data: {
        data,
        nickname
      }
    }, fee, memo, _funds);
  };
  updateParticle = async ({
    nickname,
    particle
  }: {
    nickname: string;
    particle?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_particle: {
        nickname,
        particle
      }
    }, fee, memo, _funds);
  };
  proofAddress = async ({
    address,
    nickname,
    signature
  }: {
    address: string;
    nickname: string;
    signature: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      proof_address: {
        address,
        nickname,
        signature
      }
    }, fee, memo, _funds);
  };
  removeAddress = async ({
    address,
    nickname
  }: {
    address: string;
    nickname: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_address: {
        address,
        nickname
      }
    }, fee, memo, _funds);
  };
  setOwner = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_owner: {
        owner
      }
    }, fee, memo, _funds);
  };
  setActive = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_active: {
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  setSubgraphs = async ({
    avatarSubgraph,
    nameSubgraph,
    proofSubgraph
  }: {
    avatarSubgraph: string;
    nameSubgraph: string;
    proofSubgraph: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_subgraphs: {
        avatar_subgraph: avatarSubgraph,
        name_subgraph: nameSubgraph,
        proof_subgraph: proofSubgraph
      }
    }, fee, memo, _funds);
  };
  setAddressLabel = async ({
    address,
    label,
    nickname
  }: {
    address: string;
    label?: string;
    nickname: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_address_label: {
        address,
        label,
        nickname
      }
    }, fee, memo, _funds);
  };
  transferNft = async ({
    recipient,
    tokenId
  }: {
    recipient: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_nft: {
        recipient,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  sendNft = async ({
    contract,
    msg,
    tokenId
  }: {
    contract: string;
    msg: Binary;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_nft: {
        contract,
        msg,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  mint = async ({
    extension,
    owner,
    tokenId,
    tokenUri
  }: {
    extension: PassportMetadata;
    owner: string;
    tokenId: string;
    tokenUri?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mint: {
        extension,
        owner,
        token_id: tokenId,
        token_uri: tokenUri
      }
    }, fee, memo, _funds);
  };
  burn = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn: {
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  approve = async ({
    expires,
    spender,
    tokenId
  }: {
    expires?: Expiration;
    spender: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      approve: {
        expires,
        spender,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  revoke = async ({
    spender,
    tokenId
  }: {
    spender: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke: {
        spender,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  approveAll = async ({
    expires,
    operator
  }: {
    expires?: Expiration;
    operator: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      approve_all: {
        expires,
        operator
      }
    }, fee, memo, _funds);
  };
  revokeAll = async ({
    operator
  }: {
    operator: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke_all: {
        operator
      }
    }, fee, memo, _funds);
  };
}